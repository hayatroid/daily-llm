---
/**
 * Tree component - displays content hierarchy based on path
 * Uses Content Collections internally for data access
 */
import { getCollection } from 'astro:content';
import { 
  isConversationEntry, 
  extractDate, 
  createEntryUrl, 
  sortConversationsByFilename 
} from '../lib/entry-utils';

export interface Props {
  path: string; // "/" | "/2024-01-15/" | "/tags" | "/tags/react"
}

const { path } = Astro.props;

// Load all entries
const allEntries = await getCollection('daily');

let html = '';

// Determine view type from path
if (path === '/') {
  // Home: Date-based conversation listing
  const entriesByDate = new Map<string, typeof allEntries>();
  
  allEntries.forEach(entry => {
    const date = extractDate(entry);
    if (!entriesByDate.has(date)) {
      entriesByDate.set(date, []);
    }
    entriesByDate.get(date).push(entry);
  });

  const sortedDates = Array.from(entriesByDate.keys()).sort().reverse();
  
  html += `<div class="tree-level-0"><a href="/" class="tree-link">Home/</a></div>`;
  
  sortedDates.forEach(date => {
    const dateEntries = entriesByDate.get(date);
    const conversations = dateEntries.filter(isConversationEntry);
    
    html += `<div class="tree-level-1">`;
    html += `<a href="/${date}/" class="tree-link">${date}/</a>`;
    if (conversations.length > 0) {
      html += `<span class="tree-meta">${conversations.length} conversations</span>`;
    }
    html += `</div>`;
    
    sortConversationsByFilename(conversations).forEach(entry => {
      html += `<div class="tree-level-2">`;
      html += `<a href="${createEntryUrl(entry)}" class="tree-link">${entry.data.title}</a>`;
      if (entry.data.time) {
        html += `<span class="tree-meta">${entry.data.time}</span>`;
      }
      html += `</div>`;
    });
  });

} else if (path === '/tags') {
  // Tags index: List all tags with counts
  const conversationEntries = allEntries.filter(isConversationEntry);
  const tagCounts = new Map<string, number>();
  
  conversationEntries.forEach(entry => {
    if (entry.data.tags && Array.isArray(entry.data.tags)) {
      entry.data.tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    }
  });

  const sortedTags = Array.from(tagCounts.keys()).sort((a, b) => 
    a.toLowerCase().localeCompare(b.toLowerCase())
  );

  html += `<div class="tree-level-0"><a href="/tags/" class="tree-link">tags/</a></div>`;
  
  sortedTags.forEach(tagName => {
    const count = tagCounts.get(tagName);
    html += `<div class="tree-level-1">`;
    html += `<a href="/tags/${encodeURIComponent(tagName)}/" class="tree-link">#${tagName}</a>`;
    html += `<span class="tree-meta">${count} conversation${count !== 1 ? 's' : ''}</span>`;
    html += `</div>`;
  });

  if (sortedTags.length === 0) {
    html += `<div class="tree-level-1"><span class="tree-meta">(no tags found)</span></div>`;
  }

} else if (path.startsWith('/tags/')) {
  // Specific tag: Show conversations with this tag grouped by date
  const tag = path.replace('/tags/', '').replace(/\/$/, '');
  const conversationEntries = allEntries.filter(isConversationEntry);
  const taggedConversations = conversationEntries.filter(entry => 
    entry.data.tags && 
    Array.isArray(entry.data.tags) && 
    entry.data.tags.includes(tag)
  );

  const dateGroups = new Map<string, typeof allEntries>();
  taggedConversations.forEach(entry => {
    const date = extractDate(entry);
    if (!dateGroups.has(date)) {
      dateGroups.set(date, []);
    }
    dateGroups.get(date).push(entry);
  });

  const sortedDates = Array.from(dateGroups.keys()).sort((a, b) => 
    new Date(b).getTime() - new Date(a).getTime()
  );

  html += `<div class="tree-level-0">`;
  html += `<a href="/tags/${encodeURIComponent(tag)}/" class="tree-link">#${tag}/</a>`;
  html += `<span class="tree-meta">${taggedConversations.length} conversations</span>`;
  html += `</div>`;

  sortedDates.forEach(date => {
    const conversations = dateGroups.get(date);
    
    html += `<div class="tree-level-1">`;
    html += `<a href="/${date}/" class="tree-link">${date}/</a>`;
    html += `<span class="tree-meta">${conversations.length} conversations</span>`;
    html += `</div>`;
    
    sortConversationsByFilename(conversations).forEach(entry => {
      html += `<div class="tree-level-2">`;
      html += `<a href="${createEntryUrl(entry)}" class="tree-link">${entry.data.title}</a>`;
      if (entry.data.time) {
        html += `<span class="tree-meta">${entry.data.time}</span>`;
      }
      html += `</div>`;
    });
  });

  if (sortedDates.length === 0) {
    html += `<div class="tree-level-1"><span class="tree-meta">(no conversations found for this tag)</span></div>`;
  }

} else {
  // Specific date: Show conversations in this date
  const targetDate = path.replace(/^\/|\/$/g, '');
  const dateEntries = allEntries.filter(entry => extractDate(entry) === targetDate);
  const conversations = dateEntries.filter(isConversationEntry);
  
  html += `<div class="tree-level-0"><a href="/${targetDate}/" class="tree-link">${targetDate}/</a></div>`;
  
  sortConversationsByFilename(conversations).forEach(entry => {
    html += `<div class="tree-level-1">`;
    html += `<a href="${createEntryUrl(entry)}" class="tree-link">${entry.data.title}</a>`;
    if (entry.data.time) {
      html += `<span class="tree-meta">${entry.data.time}</span>`;
    }
    html += `</div>`;
  });
}
---

<div class="tree-container" set:html={html}></div>